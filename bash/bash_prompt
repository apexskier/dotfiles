#!/bin/bash

#set -x

unset color_prompt force_color_prompt

    nocol="\[\033[m\]"
    black="\[\033[0;30m\]"
     blue="\[\033[0;34m\]"
    green="\[\033[0;32m\]"
     cyan="\[\033[0;36m\]"
      red="\[\033[0;31m\]"
   purple="\[\033[0;35m\]"
    brown="\[\033[0;33m\]"
  lt_grey="\[\033[0;37m\]"
  dk_grey="\[\033[1;30m\]"
  lt_blue="\[\033[1;34m\]"
 lt_green="\[\033[1;32m\]"
  lt_cyan="\[\033[1;36m\]"
   lt_red="\[\033[1;31m\]"
lt_purple="\[\033[1;35m\]"
   yellow="\[\033[1;33m\]"
    white="\[\033[1;37m\]"
     fade="\033[2m\]"

function __dotfiles_pre_command() {
    [[ -z "$__dotfiles_at_prompt" ]] && return
    unset __dotfiles_at_prompt

    __dotfiles_timer_start=$(date +%s.%N)
}
trap __dotfiles_pre_command DEBUG

username=""
# highlighted cyan for root, grey if the user is not the login one, else cyan
if [[ "$EUID" -ne "0" ]] ; then  # if user is not root
    # if user is not login user
    if [[ $USER != "$(logname 2>/dev/null || echo $LOGNAME)" ]]; then
        username="$lt_grey"
    else
        username="$cyan"
    fi
else # root!
    username="$lt_cyan"
fi
username+="\u$nocol"

get_connection_type() {
    if [ -f /.dockerenv ]
    then
        echo docker
    elif [[ -n "$SSH_CLIENT$SSH2_CLIENT$SSH_TTY" ]]
    then
        echo ssh
    else
        # TODO check on *BSD
        local sess_src
        sess_src="$(who am i | sed -n 's/.*(\(.*\))/\1/p')"
        local sess_parent
        sess_parent="$(ps -o comm= -p $PPID 2> /dev/null)"
        if [[ -z "$sess_src" || "$sess_src" = ":"* ]] ; then
            echo lcl # Local
        elif [[ "$sess_parent" = "su" || "$sess_parent" = "sudo" ]] ; then
            echo su  # Remote su/sudo
        else
            echo tel # Telnet
        fi
    fi
}
connectionmark=""
CONNECTION_TYPE=$(get_connection_type)
# https://en.wikipedia.org/wiki/Arrows_(Unicode_block)
case "$CONNECTION_TYPE" in
ssh)
    connectionmark="⇝"
    ;;
tel)
    connectionmark="⇢"
    ;;
docker)
    connectionmark="⇨"
esac

# highlight mark if windowing is supported
displaymark="@"
# If we are connected with X11 support (remote windowing on linux)
if [[ -n "$DISPLAY" ]] ; then
    displaymark="$white$displaymark$nocol"
else
    displaymark="$lt_grey$displaymark$nocol"
fi

# make this a little less prominent and different from normal text
# I don't use $ because it means something in bash
PS2="${lt_grey}↪ ${nocol}"

function gitinfo() {
    local gitbranch
    gitbranch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
    if [[ -n "$gitbranch" ]]; then
        printf "±%s" "$gitbranch"
    fi
}

function nodeinfo() {
    if command -v node >/dev/null 2>&1; then
        if ! file_in_tree package.json > /dev/null; then
            return
        fi

        # too slow :(
        # if command -v npm >/dev/null 2>&1; then
        #     local npm_prefix=$(npm prefix)
        #     if [[ -f "$npm_prefix/package.json" ]] ; then
        #         if ! npx -q check-node-version --node "$(node -e "process.stdout.write((require('$npm_prefix/package.json').engines || {}).node || '')")" > /dev/null 2>&1 ; then
        #             printf "$red"
        #         fi
        #     fi
        # fi

        local node_version
        node_version="$(node --version)"
        # alt ⬡
        printf "⬢%s" "$node_version"
    fi
}

function goinfo() {
    if command -v go >/dev/null 2>&1; then
        local gomodfile
        if ! gomodfile=$(file_in_tree go.mod); then
            return
        fi

        local gotoolchain
        gotoolchain=$(go env GOTOOLCHAIN)

        local gomodversion
        gomodversion=$(grep '^go ' "$gomodfile")
        gomodversion=${gomodversion}
        gomodtoolchain="go${gomodversion:3}"

        if [ "$gotoolchain" = "local" ]; then
            gotoolchain="$gomodtoolchain"
        fi

        if [ "$gomodtoolchain" != "$gotoolchain" ]; then
            printf "%s%s%s" "$red" "$gotoolchain" "$nocol"
        else
            echo -n "$gotoolchain"
        fi

    fi
}

function k8sinfo() {
    if command -v kubectl >/dev/null 2>&1; then
        local context
        context=$(kubectl config view --minify --output=go-template --template='{{ index . "current-context" }}' 2> /dev/null)
        if [[ -n "$context" ]] ; then
            printf "⎈%s" "$context"
        fi
    fi
}

function gcloudinfo() {
    if command -v gcloud >/dev/null 2>&1; then
        local configName
        # gcloud cli has some weird output, we're reading from something odd
        configName=$(gcloud --format=text config get-value project 2>&1 | head -n1 | cut -d '[' -f2 | cut -d ']' -f1)
        if [[ -n "$configName" ]] ; then
            printf "☁%s" "$configName"
        fi
    fi
}

function exit_conventional() {
    case "$1" in
    # common conventions
    1) echo "ERROR";;
    2) echo "USAGE";;
    126) echo "NOPERM";;
    127) echo "NOTFOUND";;
    *) return 1
    esac
}

function exit_signal() {
    case "$1" in
    # signals
    129) echo "HUP";;
    130) echo "INT";;
    131) echo "QUIT";;
    132) echo "ILL";;
    133) echo "TRAP";;
    134) echo "IOT";;
    135) echo "BUS";;
    136) echo "FPE";;
    137) echo "KILL";;
    138) echo "USR1";;
    139) echo "SEGV";;
    140) echo "USR2";;
    141) echo "PIPE";;
    142) echo "ALRM";;
    143) echo "TERM";;
    144) echo "STKFLT";;
    145) echo "CHLD";;
    146) echo "CONT";;
    147) echo "STOP";;
    148) echo "TSTP";;
    149) echo "TTIN";;
    150) echo "TTOU";;
    *) return 1
    esac
}

function exitinfo() {
    local desc
    if desc=$(exit_signal "$1"); then
        printf "%s%s%s" "$red" "$desc" "$nocol"
    elif desc=$(exit_conventional "$1"); then
        printf "%s%s%s %s(%s)%s" "$red" "$1" "$nocol" "$fade" "$desc" "$nocol"
    else
        printf "%s%s%s" "$red" "$1" "$nocol"
    fi
}

function format_duration() {
    local duration=$1
    local hours=$((duration / 3600))
    local minutes=$(((duration % 3600) / 60))
    local seconds=$((duration % 60))

    if (( hours > 0 )); then
        printf "%dh%dm%ds" $hours $minutes $seconds
    elif (( minutes > 0 )); then
        printf "%dm%ds" $minutes $seconds
    else
        printf "%ds" $seconds
    fi
}

function timerinfo() {
    if [[ -z "$__dotfiles_timer_start" ]]; then
        return
    fi

    local duration
    duration=$(echo "$(date +%s.%N) - $__dotfiles_timer_start" | bc -l)
    printf -v duration '%.0f' "$duration"

    # Only show if command took more than 1 second
    if (( duration >= 1 )); then
        local formatted
        formatted=$(format_duration "$duration")

        printf "%s⏱ " $dk_grey

        if (( duration >= 60 )); then
            printf "%s" "$red"
        elif (( duration >= 10 )); then
            printf "%s" "$yellow"
        fi

        printf "%s%s" "$formatted" "$nocol"
    fi
}

__dotfiles_prompt_gitinfo_file=$(mktemp)
__dotfiles_prompt_nodeinfo_file=$(mktemp)
__dotfiles_prompt_goinfo_file=$(mktemp)
__dotfiles_prompt_k8sinfo_file=$(mktemp)
__dotfiles_prompt_gcloudinfo_file=$(mktemp)

# joins arguments with a delimiter
# usage: join "delimiter" "first" "second" "third" ...
# output: firstdelimiterseconddelimiterthird
function join {
    local d=${1-} f=${2-}
    if shift 2; then
        printf %s "${f[@]}" "${@/#/$d}"
    fi
}

# filters out empty arguments and returns the rest
# usage: filter_empty "first" "" "second" "third" ""
# output: first second third
function filter_empty {
    filtered=()
    for item in "$@"; do
        if [[ -n "$item" ]]; then
            filtered+=("$item")
        fi
    done
    echo "${filtered[@]}"
}

# maps a list
# usage: map_format "(%s)" "first" "second" "third"
# output: (first) (second) (third)
function map_format {
    local format=$1
    shift
    mapped=()
    for item in "$@"; do
        # shellcheck disable=SC2059
        mapped+=("$(printf "$format" "$item")")
    done
    echo "${mapped[@]}"
}

function set_prompt() {
    # get exit info of last cmd before running any more
    local -i last_err=$?
    local cmd_info=()
    if (( last_err != 0 )); then
        cmd_info+=("$(exitinfo $last_err)")
    fi
    cmd_info+=("$(timerinfo)")
    cmd_info_str=$(join " " "${cmd_info[@]}")
    if [[ -n "$cmd_info_str" ]]; then
        cmd_info_str="↩ $cmd_info_str\n"
    fi

    history -a

    local ret

    # exit info of last command
    ret+="$cmd_info_str"

    # username, display mark, connnection type, hostname
    ret+="$username$displaymark$connectionmark$green\h$nocol"

    # write permission indicator
    local write=":"
    if [[ -w "$PWD" ]] ; then
        write="$green$write$nocol"
    else
        write="$red$write$nocol"
    fi
    ret+="$write"

    # current working directory
    ret+="$yellow\w$nocol"

    # timestamp
    ret+=" $dk_grey$(date +"%H:%M:%S")$nocol"

    # environment info (parallelized)
    local venv
    if [[ -n "$VIRTUAL_ENV" ]] ; then
        venv="⊙${VIRTUAL_ENV#"$WORKON_HOME"/}"
    fi

    local gitinfo_file="$__dotfiles_prompt_gitinfo_file"
    gitinfo > "$gitinfo_file" &
    local nodeinfo_file="$__dotfiles_prompt_nodeinfo_file"
    nodeinfo > "$nodeinfo_file" &
    local goinfo_file="$__dotfiles_prompt_goinfo_file"
    goinfo > "$goinfo_file" &
    local k8sinfo_file="$__dotfiles_prompt_k8sinfo_file"
    k8sinfo > "$k8sinfo_file" &
    local gcloudinfo_file="$__dotfiles_prompt_gcloudinfo_file"
    gcloudinfo > "$gcloudinfo_file" &

    wait

    gitinfo=$(cat "$gitinfo_file")
    nodeinfo=$(cat "$nodeinfo_file")
    goinfo=$(cat "$goinfo_file")
    k8sinfo=$(cat "$k8sinfo_file")
    gcloudinfo=$(cat "$gcloudinfo_file")

    # environment information
    local filtered_items formatted_items environment
    read -r -a filtered_items < <(filter_empty "$gitinfo" "$venv" "$nodeinfo" "$goinfo" "$k8sinfo" "$gcloudinfo")
    read -r -a formatted_items < <(map_format "$fade(%s$fade)$nocol" "${filtered_items[@]}")
    environment=$(join " " "${formatted_items[@]}")

    # this stuff can be used for _responsive_ design
    # it doesn't work though, since $ret doesn't expand custom prompt variables
    # local size
    # read -r -a size < <(stty size)
    # # local rows=${size[0]}
    # local cols=${size[1]}
    # test "$((${#ret} + 1 + ${#environment}))" -gt "$cols" && ret+="\n"

    if [ ${#formatted_items[@]} -gt 0 ] ; then
        ret+="\n"
        ret+=$environment
    fi

    # command prompt on a new line, so I can read long commands easier
    ret+="\n$PS2"

    PS1=$ret

    # custom terminal title
    # echo -ne "\033]0;${connectionmark}\007"
    echo -ne "\033]0;\007\c"
}

function post_prompt_cleanup() {
    __dotfiles_at_prompt=1
}

export PROMPT_COMMAND="set_prompt;$PROMPT_COMMAND;post_prompt_cleanup"
export CLICOLOR=1
export LSCOLORS=ExFxBxDxCxegedabagacad
